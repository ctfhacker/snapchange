diff --git a/target/i386/tcg/translate.c b/target/i386/tcg/translate.c
index e0a622941c..25fe8f54ee 100644
--- a/target/i386/tcg/translate.c
+++ b/target/i386/tcg/translate.c
@@ -69,6 +69,62 @@
 
 //#define MACRO_TEST   1
 
+#ifdef SNAPCHANGE
+#include "monitor/hmp.h"
+#include "monitor/monitor.h"
+#include "qapi/qmp/qdict.h"
+void dump_physical_memory(uint64_t addr, uint64_t size, const char* filename);
+void dump_regs(CPUState *cpu, const char* filename);
+#endif
+
+
+/// Write `size` physical memory bytes starting from `addr` into `filename`
+void dump_physical_memory(uint64_t addr, uint64_t size, const char* filename) {
+    Error *err = NULL;
+    printf("Calling pmemsave.. addr 0x%lx size 0x%lx", addr, size);
+
+    // Call `qmp_pmemsave` to write the physical memory
+    qmp_pmemsave(addr, size, filename, &err);
+
+    printf("Done dumping physical memory in %s\n", filename);
+}
+
+void dump_regs(CPUState *cpu, const char* filename) {
+    FILE* f = fopen(filename, "w");
+    if (!f) {
+        printf("Failed to open file for registers: %s", filename);
+        return;
+    }
+
+    X86CPU *x86_cpu = X86_CPU(cpu);
+    CPUX86State *state = &x86_cpu->env;
+    uint8_t code[3];
+    if (
+        // `vmcall` is 0f 01 c1
+        cpu_memory_rw_debug(cpu, state->eip + 0, &code, 3, 0) == 0
+            && code[0] == 0x0f
+            && code[1] == 0x01
+            && code[2] == 0xc1
+    ) {
+        // Move RIP past the `vmcall` instruction for this snapshot
+        state->eip += 3;
+    }
+
+    printf("Calling dump registers.. ");
+    x86_cpu_dump_state(cpu, f, 0x70000);
+    printf("Done dumping registers in %s\n", filename);
+
+    CPUArchState *env = cpu->env_ptr;
+    fprintf(f, "APIC_BASE=%lx\n", cpu_get_apic_base(env_archcpu(env)->apic_state));
+    fprintf(f, "EFER=%lx\n", env->efer);
+    fprintf(f, "STAR=%lx\n", env->star);
+    fprintf(f, "LSTAR=%lx\n", env->lstar);
+    fprintf(f, "CSTAR=%lx\n", env->cstar);
+    fprintf(f, "SFMASK=%lx\n", env->fmask);
+    fprintf(f, "KERNELGSBASE=%lx\n", env->kernelgsbase);
+    fclose(f);
+}
+
 /* global register indexes */
 static TCGv cpu_cc_dst, cpu_cc_src, cpu_cc_src2;
 static TCGv cpu_eip;
@@ -3087,6 +3143,7 @@ static bool disas_insn(DisasContext *s, CPUState *cpu)
     bool orig_cc_op_dirty = s->cc_op_dirty;
     CCOp orig_cc_op = s->cc_op;
     target_ulong orig_pc_save = s->pc_save;
+    uint64_t physmem_dump_size;
 
     s->pc = s->base.pc_next;
     s->override = -1;
@@ -5845,6 +5902,25 @@ static bool disas_insn(DisasContext *s, CPUState *cpu)
             gen_op_st_v(s, CODE64(s) + MO_32, s->T0, s->A0);
             break;
 
+        case 0xc1: /* vmcall */
+            // Default to 5G for the physmem size
+            physmem_dump_size = (uint64_t)(5 * 1024 * 1024) * 1024;
+            char* physmem_size = getenv("QEMU_MEM");
+
+            // Convert [1-9]G into number of bytes with 1G of padding
+            // The CR3 was seen to sometimes be outside of the given QEMU_MEM, so the padding
+            // was added
+            if(physmem_size != 0) { 
+                if (physmem_size[0] >= '1' && physmem_size[0] <= '9' && physmem_size[1] == 'G') {
+                    physmem_dump_size = (((uint64_t)atoi(&physmem_size[0]) + 1) * 1024 * 1024) * 1024;
+                }
+            }
+
+            printf("Physmem dump size: 0x%lx\n", physmem_dump_size);
+            dump_regs(cpu, "fuzzvm.qemuregs");
+            dump_physical_memory(0,  physmem_dump_size, "fuzzvm.physmem");
+            break;
+
         case 0xc8: /* monitor */
             if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || CPL(s) != 0) {
                 goto illegal_op;
